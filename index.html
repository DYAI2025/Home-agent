<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LiveKit Voice Agent Cockpit</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.min.js"></script>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    :root {
      color-scheme: dark light;
      --bg: #0c111d;
      --panel: rgba(20, 26, 40, 0.85);
      --accent: #4cc9f0;
      --accent-strong: #4361ee;
      --border: rgba(255, 255, 255, 0.1);
      --text: #f8fbff;
      --muted: rgba(255, 255, 255, 0.68);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(circle at top left, rgba(76, 201, 240, 0.18), transparent 45%),
                  radial-gradient(circle at top right, rgba(67, 97, 238, 0.16), transparent 50%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 24px;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 16px;
    }

    header h1 {
      margin: 0;
      font-size: 1.75rem;
      font-weight: 700;
    }

    header .badge {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(76, 201, 240, 0.16);
      border: 1px solid rgba(76, 201, 240, 0.35);
      color: var(--accent);
      font-size: 0.85rem;
      font-weight: 600;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(360px, 1fr) minmax(420px, 1.2fr);
      gap: 18px;
      padding: 0 24px 24px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 20px;
      backdrop-filter: blur(10px) saturate(140%);
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .panel h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }

    .control-buttons {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      justify-content: flex-start;
      grid-column: 1 / -1;
    }

    .control-buttons button {
      flex: 1;
      min-width: 140px;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    input, select, button, textarea {
      font: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: inherit;
    }

    input:focus, select:focus, textarea:focus, button:focus {
      outline: 2px solid rgba(76, 201, 240, 0.35);
      outline-offset: 1px;
    }

    button {
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, background 160ms ease;
    }

    button.primary {
      background: linear-gradient(135deg, var(--accent-strong), var(--accent));
      border: none;
      color: #fff;
      box-shadow: 0 10px 24px rgba(67, 97, 238, 0.35);
    }

    button.secondary,
    a.secondary {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
    }

    .video-stage {
      position: relative;
      background: rgba(0, 0, 0, 0.45);
      border-radius: 16px;
      overflow: hidden;
      aspect-ratio: 16 / 9;
      display: grid;
      place-items: center;
    }

    video, audio {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    audio {
      display: none;
    }

    .video-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.95rem;
      text-align: center;
    }

    .status-banner {
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(67, 97, 238, 0.08);
      border: 1px solid rgba(67, 97, 238, 0.24);
      color: var(--muted);
      font-size: 0.9rem;
    }

    .chat-log {
      flex: 1;
      min-height: 180px;
      max-height: 280px;
      overflow-y: auto;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.35);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .message {
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.9rem;
      line-height: 1.35;
      word-break: break-word;
      background: rgba(255, 255, 255, 0.06);
    }

    .message.system {
      color: var(--muted);
      font-style: italic;
    }

    .message.user {
      align-self: flex-end;
      background: rgba(76, 201, 240, 0.22);
    }

    .message.agent {
      align-self: flex-start;
      background: rgba(67, 97, 238, 0.22);
    }

    .chat-input {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }

    .chat-input input {
      flex: 1;
    }

    .avatar-grid {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 16px;
    }

    model-viewer {
      width: 100%;
      height: 360px;
      background: rgba(0, 0, 0, 0.35);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    iframe {
      width: 100%;
      height: 460px;
      border: none;
      border-radius: 16px;
      background: #000;
    }

    .avatar-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .avatar-url {
      font-size: 0.8rem;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.4);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      word-break: break-all;
    }

    footer {
      padding: 18px 24px 28px;
      color: var(--muted);
      font-size: 0.85rem;
      text-align: center;
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>LiveKit Voice Agent Cockpit</h1>
    <span class="badge">Ready Player Me • LiveKit • AI Agent</span>
  </header>

  <main>
    <section class="panel" id="session-panel">
      <h2>Realtime session</h2>

      <form class="controls" id="connectForm">
        <label>
          Room name
          <input type="text" id="roomInput" name="room" value="avatar-room" autocomplete="off" />
        </label>
        <label>
          Your identity
          <input type="text" id="identityInput" name="identity" value="pilot" autocomplete="off" />
        </label>
        <div class="control-buttons">
          <button type="submit" class="primary" id="connectBtn">Connect</button>
          <button type="button" class="secondary" id="disconnectBtn" disabled>Disconnect</button>
        </div>
      </form>

      <div class="status-banner" id="status">Status: idle</div>

      <div class="video-stage" id="videoStage">
        <video id="remoteVideo" autoplay playsinline></video>
        <audio id="remoteAudio" autoplay></audio>
        <div class="video-placeholder" id="videoPlaceholder">
          <span>Waiting for remote media…</span>
        </div>
      </div>

      <div class="chat-log" id="chatLog">
        <div class="message system">Connect to a room to exchange data messages with the agent.</div>
      </div>

      <div class="chat-input">
        <input type="text" id="messageInput" placeholder="Send a message to the agent" autocomplete="off" />
        <button type="button" class="secondary" id="sendMessageBtn" disabled>Send</button>
      </div>
    </section>

    <section class="panel" id="avatar-panel">
      <h2>Avatar studio</h2>
      <div class="avatar-grid">
        <model-viewer id="avatarViewer" shadow-intensity="1" camera-controls auto-rotate ar></model-viewer>
        <div class="avatar-actions">
          <button type="button" class="secondary" id="toggleCreatorBtn">Open avatar creator</button>
          <a class="secondary" id="downloadAvatarBtn" href="#" download="ready-player-me-avatar.glb">Download GLB</a>
          <button type="button" class="secondary" id="copyAvatarUrlBtn">Copy URL</button>
        </div>
        <div class="avatar-url" id="avatarUrl">Avatar URL: not loaded yet</div>
        <iframe id="rpmFrame" allow="camera *; microphone *; clipboard-write" hidden></iframe>
      </div>
    </section>
  </main>

  <footer>
    Configure <code>LIVEKIT_URL</code>, <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code> to connect to your deployment. Use the Ready Player Me creator to refresh the avatar visible above.
  </footer>

  <script>
    const statusDiv = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const sendMessageBtn = document.getElementById('sendMessageBtn');
    const messageInput = document.getElementById('messageInput');
    const chatLog = document.getElementById('chatLog');
    const remoteVideo = document.getElementById('remoteVideo');
    const remoteAudio = document.getElementById('remoteAudio');
    const videoPlaceholder = document.getElementById('videoPlaceholder');

    let room = null;

    function setStatus(text) {
      statusDiv.textContent = text;
    }

    function appendMessage(type, text) {
      const message = document.createElement('div');
      message.classList.add('message', type);
      message.innerHTML = `<strong>${type === 'user' ? 'You' : type === 'agent' ? 'Agent' : 'System'}:</strong> ${text}`;
      chatLog.appendChild(message);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function setControlsConnected(isConnected) {
      connectBtn.disabled = isConnected;
      disconnectBtn.disabled = !isConnected;
      sendMessageBtn.disabled = !isConnected;
      messageInput.disabled = !isConnected;
      if (!isConnected) {
        videoPlaceholder.style.display = 'flex';
        remoteVideo.srcObject = null;
      }
    }

    async function connectToRoom(roomName, identity) {
      setStatus(`Connecting to ${roomName}…`);
      appendMessage('system', `Connecting to ${roomName} as ${identity}`);

      try {
        const response = await fetch(`/token?room=${encodeURIComponent(roomName)}&identity=${encodeURIComponent(identity)}`);
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: response.statusText }));
          throw new Error(error.error || 'Unable to fetch token');
        }

        const { token, url } = await response.json();
        room = await LiveKit.connect(url, token, { autoSubscribe: true });

        registerRoomHandlers();
        setControlsConnected(true);
        setStatus(`Connected to ${roomName}`);
        videoPlaceholder.style.display = 'none';
        appendMessage('system', 'Connected. Media tracks will appear automatically when the agent publishes them.');
      } catch (error) {
        console.error('Connection error:', error);
        appendMessage('system', `Connection failed: ${error.message}`);
        setStatus(`Error: ${error.message}`);
        setControlsConnected(false);
        room = null;
      }
    }

    function registerRoomHandlers() {
      if (!room) return;

      room.on(LiveKit.RoomEvent.TrackSubscribed, (track, publication, participant) => {
        if (track.kind === LiveKit.Track.Kind.Video) {
          track.attach(remoteVideo);
        }
        if (track.kind === LiveKit.Track.Kind.Audio) {
          track.attach(remoteAudio);
        }
      });

      room.on(LiveKit.RoomEvent.TrackUnsubscribed, (track) => {
        track.detach();
      });

      room.on(LiveKit.RoomEvent.DataReceived, (payload, participant) => {
        const text = new TextDecoder().decode(payload);
        appendMessage('agent', text);
      });

      room.on(LiveKit.RoomEvent.Disconnected, () => {
        appendMessage('system', 'Disconnected from room');
        setStatus('Disconnected');
        setControlsConnected(false);
        room = null;
      });
    }

    async function disconnectFromRoom() {
      if (room) {
        await room.disconnect();
        room = null;
        appendMessage('system', 'You left the room');
      }
      setStatus('Disconnected');
      setControlsConnected(false);
    }

    async function sendMessage() {
      const text = messageInput.value.trim();
      if (!text || !room) return;

      appendMessage('user', text);
      messageInput.value = '';
      try {
        const payload = new TextEncoder().encode(text);
        await room.localParticipant.publishData(payload, LiveKit.DataPacket_Kind.RELIABLE);
      } catch (error) {
        console.error('Failed to send data message:', error);
        appendMessage('system', `Sending failed: ${error.message}`);
      }
    }

    document.getElementById('connectForm').addEventListener('submit', (event) => {
      event.preventDefault();
      const roomName = event.target.room.value.trim() || 'avatar-room';
      const identity = event.target.identity.value.trim() || `pilot-${Date.now()}`;
      connectToRoom(roomName, identity);
    });

    disconnectBtn.addEventListener('click', () => {
      disconnectFromRoom();
    });

    sendMessageBtn.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        sendMessage();
      }
    });

    setControlsConnected(false);

    // Ready Player Me integration
    const rpmFrame = document.getElementById('rpmFrame');
    const avatarViewer = document.getElementById('avatarViewer');
    const avatarUrlLabel = document.getElementById('avatarUrl');
    const toggleCreatorBtn = document.getElementById('toggleCreatorBtn');
    const copyAvatarUrlBtn = document.getElementById('copyAvatarUrlBtn');
    const downloadAvatarBtn = document.getElementById('downloadAvatarBtn');

    const readyPlayerMeDomain = 'demo.readyplayer.me';
    rpmFrame.src = `https://${readyPlayerMeDomain}/avatar?frameApi`;

    function handleReadyPlayerMeMessage(event) {
      if (!event.data) return;
      const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
      if (data.source !== 'readyplayerme') return;

      if (data.eventName === 'v1.frame.ready') {
        rpmFrame.contentWindow.postMessage(JSON.stringify({
          target: 'readyplayerme',
          type: 'subscribe',
          eventName: 'v1.**'
        }), '*');
      }

      if (data.eventName === 'v1.avatar.exported') {
        const url = data.data?.url;
        if (!url) return;
        avatarViewer.src = url;
        avatarUrlLabel.textContent = `Avatar URL: ${url}`;
        downloadAvatarBtn.href = url;
        rpmFrame.hidden = true;
      }
    }

    window.addEventListener('message', handleReadyPlayerMeMessage);

    toggleCreatorBtn.addEventListener('click', () => {
      rpmFrame.hidden = !rpmFrame.hidden;
      toggleCreatorBtn.textContent = rpmFrame.hidden ? 'Open avatar creator' : 'Hide avatar creator';
    });

    copyAvatarUrlBtn.addEventListener('click', async () => {
      const text = avatarUrlLabel.textContent.replace('Avatar URL: ', '').trim();
      if (!text || text === 'not loaded yet') return;
      try {
        await navigator.clipboard.writeText(text);
        copyAvatarUrlBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyAvatarUrlBtn.textContent = 'Copy URL';
        }, 1500);
      } catch (error) {
        console.warn('Clipboard unavailable:', error);
      }
    });
  </script>
</body>
</html>
