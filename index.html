<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LiveKit Voice Agent Cockpit</title>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script src="/config.js" defer></script>
    <style>
      :root { color-scheme: dark; --bg:#090b15; --panel:#11162b; --accent:#63f5ff;
        --accent-muted:rgba(99,245,255,0.35); --text:#f4f7ff; --text-muted:#9aa4c4;
        --danger:#ff6b8a; --success:#7dffb2; --radius:16px; --shadow:0 22px 45px rgba(5,8,20,.45); }
      *{box-sizing:border-box;} html,body{height:100%;}
      body{margin:0;font-family:"Inter","Segoe UI",system-ui,-apple-system,sans-serif;
        color:var(--text);background:radial-gradient(1400px 900px at 5% -10%,#1c2742 0%,#0d1020 45%,#05060c 100%);
        display:flex;flex-direction:column;}
      header{padding:20px 28px 12px;display:flex;align-items:center;justify-content:space-between;backdrop-filter:saturate(140%) blur(12px);}
      header h1{margin:0;font-size:22px;letter-spacing:.3px;}
      header .chip{padding:6px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.06);color:var(--text-muted);font-size:13px;}
      main{flex:1;display:grid;grid-template-columns:minmax(420px,1.1fr) minmax(420px,1fr);gap:20px;padding:0 24px 24px;}
      .panel{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);
        border-radius:var(--radius);box-shadow:var(--shadow);padding:18px 20px 22px;display:flex;flex-direction:column;min-height:0;}
      .panel h2{margin:0 0 14px;font-size:16px;font-weight:600;text-transform:uppercase;letter-spacing:.16em;color:var(--text-muted);}
      .viewer{position:relative;border-radius:14px;overflow:hidden;border:1px solid rgba(255,255,255,.08);background:#05070f;min-height:360px;}
      model-viewer{width:100%;height:100%;min-height:360px;display:block;}
      .controls{display:grid;gap:10px;margin-top:16px;}
      .controls .row{display:flex;flex-wrap:wrap;gap:10px;}
      select,input,button{padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(10,14,25,.8);color:var(--text);font-size:14px;}
      select,input{flex:1;min-width:0;}
      button{cursor:pointer;font-weight:600;letter-spacing:.2px;transition:transform .08s ease,background .2s ease,border .2s ease;}
      button:hover{transform:translateY(-1px);} button.primary{background:linear-gradient(130deg,rgba(99,245,255,.35),rgba(151,118,255,.35));border-color:rgba(99,245,255,.55);}
      button.ghost{background:rgba(255,255,255,.05);}
      .status-line{margin-top:10px;font-size:13px;color:var(--text-muted);}
      .pill{margin-top:12px;display:inline-flex;align-items:center;gap:8px;padding:6px 12px;border-radius:999px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.08);font-size:13px;}
      iframe{width:100%;height:520px;border:none;border-radius:14px;margin-top:14px;background:#000;}
      .chat-log{flex:1;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(7,10,18,.8);padding:14px;overflow-y:auto;font-size:14px;line-height:1.45;}
      .chat-message{margin-bottom:10px;padding:10px 12px;border-radius:10px;max-width:92%;}
      .chat-message.system{background:rgba(255,255,255,.04);color:var(--text-muted);}
      .chat-message.user{background:rgba(125,255,178,.12);border:1px solid rgba(125,255,178,.35);}
      .chat-message.agent{background:rgba(99,245,255,.12);border:1px solid rgba(99,245,255,.35);}
      .input-row{display:flex;gap:10px;margin-top:12px;}
      .grid-two{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;}
      .tiny-muted{font-size:12px;color:var(--text-muted);}
      @media(max-width:1080px){main{grid-template-columns:1fr;} iframe{height:460px;}}
    </style>
  </head>
  <body>
    <header>
      <h1>LiveKit Voice Agent Cockpit</h1>
      <div class="chip">Ready Player Me + Realtime</div>
    </header>

    <main>
      <section class="panel" id="avatarPanel">
        <h2>Avatar</h2>
        <div class="viewer">
          <model-viewer id="avatarViewer" alt="Ready Player Me Avatar" camera-controls autoplay shadow-intensity="1" exposure="0.8" interaction-prompt="none" auto-rotate></model-viewer>
        </div>
        <div class="controls">
          <div class="row">
            <select id="avatarPreset">
              <option value="">Choose preset</option>
              <option value="https://readyplayerme-avatars.s3.amazonaws.com/benchmark.glb?pose=standing">Benchmark Agent</option>
              <option value="https://readyplayerme-avatars.s3.amazonaws.com/benchmark.glb?pose=wave">Expressive Guide</option>
              <option value="https://readyplayerme-avatars.s3.amazonaws.com/benchmark.glb?pose=dynamic">Dynamic Specialist</option>
            </select>
            <button class="primary" id="loadPreset">Load Avatar</button>
          </div>
          <div class="row">
            <input type="url" id="avatarUrlInput" placeholder="Custom Ready Player Me GLB" autocomplete="off" />
            <button class="ghost" id="loadFromUrl">Use URL</button>
          </div>
          <div class="row">
            <button class="ghost" id="openCreator">Open Creator</button>
            <button class="ghost" id="closeCreator" disabled>Hide Creator</button>
            <a class="ghost" id="downloadAvatar" href="#" download>Download GLB</a>
          </div>
        </div>
        <div class="status-line" id="avatarStatus">Avatar URL: none</div>
        <iframe id="rpmFrame" hidden allow="camera *; microphone *; clipboard-write"></iframe>
        <div class="tiny-muted">Tip: set READY_PLAYER_ME_SUBDOMAIN via env if you own a custom domain.</div>
      </section>

      <section class="panel" id="sessionPanel">
        <h2>Session</h2>
        <div class="controls">
          <div class="grid-two">
            <div>
              <label class="tiny-muted" for="roomInput">Room</label>
              <input id="roomInput" value="avatar-room" autocomplete="off" />
            </div>
            <div>
              <label class="tiny-muted" for="identityInput">Identity</label>
              <input id="identityInput" value="user" autocomplete="off" />
            </div>
          </div>
          <div class="row">
            <button class="primary" id="connectBtn">Connect</button>
            <button class="ghost" id="disconnectBtn" disabled>Disconnect</button>
            <div class="pill" id="connectionTag">Status: offline</div>
          </div>
        </div>
        <div class="status-line" id="statusLine">Ready to connect.</div>
        <audio id="remoteAudio" autoplay playsinline hidden></audio>
        <video id="remoteVideo" autoplay playsinline muted hidden></video>
        <div class="chat-log" id="chatLog"></div>
        <div class="input-row">
          <input id="messageInput" placeholder="Send a chat message" autocomplete="off" disabled />
          <button id="sendBtn" class="ghost" disabled>Send</button>
        </div>
      </section>
    </main>

    <script type="module">
      async function loadLiveKitClient() {
        const localEsmUrl = '/libs/livekit-client.esm.mjs';
        const remoteEsmUrl = 'https://cdn.jsdelivr.net/npm/livekit-client@2.15.7/dist/livekit-client.esm.mjs';
        const localUmdUrl = '/libs/livekit-client.umd.min.js';
        const remoteUmdUrl = 'https://cdn.jsdelivr.net/npm/livekit-client@2.15.7/dist/livekit-client.umd.min.js';

        const tryImport = async (url) => {
          try {
            const module = await import(url);
            if (module?.Room) {
              return module;
            }
          } catch (err) {
            console.warn(`Failed to import LiveKit client from ${url}`, err);
          }
          return null;
        };

        const tryInjectScript = async (url) => {
          if (window.LiveKit) {
            return true;
          }

          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.async = true;
            script.onload = resolve;
            script.onerror = () => reject(new Error(`Failed to load LiveKit bundle: ${url}`));
            document.head.appendChild(script);
          });

          return Boolean(window.LiveKit);
        };

        const localEsm = await tryImport(localEsmUrl);
        if (localEsm) {
          return localEsm;
        }

        const remoteEsm = await tryImport(remoteEsmUrl);
        if (remoteEsm) {
          return remoteEsm;
        }

        const localUmdLoaded = await tryInjectScript(localUmdUrl).catch((err) => {
          console.warn(err.message);
          return false;
        });
        if (!localUmdLoaded) {
          await tryInjectScript(remoteUmdUrl);
        }

        if (window.LiveKit) {
          return window.LiveKit;
        }

        throw new Error('Unable to load livekit-client. Check network connectivity.');
      }

      (async () => {
        const livekit = await loadLiveKitClient();
        const {
          LocalVideoTrack,
          Room,
          RoomEvent,
          Track,
          createLocalTracks,
          setLogLevel,
        } = livekit;

        setLogLevel?.('info');

        const viewer = document.getElementById('avatarViewer');
        const avatarStatus = document.getElementById('avatarStatus');
        const avatarPreset = document.getElementById('avatarPreset');
        const avatarUrlInput = document.getElementById('avatarUrlInput');
        const loadPresetBtn = document.getElementById('loadPreset');
        const loadFromUrlBtn = document.getElementById('loadFromUrl');
        const openCreatorBtn = document.getElementById('openCreator');
        const closeCreatorBtn = document.getElementById('closeCreator');
        const downloadAvatarLink = document.getElementById('downloadAvatar');
        const rpmFrame = document.getElementById('rpmFrame');

        const roomInput = document.getElementById('roomInput');
        const identityInput = document.getElementById('identityInput');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const connectionTag = document.getElementById('connectionTag');
        const statusLine = document.getElementById('statusLine');
        const chatLog = document.getElementById('chatLog');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const remoteAudio = document.getElementById('remoteAudio');
        const remoteVideo = document.getElementById('remoteVideo');

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        let avatarReadyPromise = Promise.resolve();
        let avatarReadyResolve = null;
        let avatarVideoPublication = null;
        let publishedVideoTrack = null;
        let avatarStreamTrack = null;
        let attemptedAvatarStream = false;

        function resetAvatarReadyPromise() {
          avatarReadyPromise = new Promise((resolve) => {
            avatarReadyResolve = resolve;
          });
        }

        function markAvatarReady() {
          if (avatarReadyResolve) {
            avatarReadyResolve();
            avatarReadyResolve = null;
          }
        }

      async function waitForAvatarReady(timeoutMs = 4000) {
        let resolved = false;
        const marker = avatarReadyPromise.then(() => {
          resolved = true;
        });
        await Promise.race([marker, wait(timeoutMs)]);
        return resolved;
      }

      async function locateAvatarCanvas(maxAttempts = 20, delayMs = 120) {
        await waitForAvatarReady();
        for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
          const host = viewer.renderRoot || viewer.shadowRoot;
          const canvas = host?.querySelector('canvas');
          if (canvas) {
            return canvas;
          }
          await wait(delayMs);
        }
        return null;
      }

      async function startAvatarVideoTrack(room) {
        if (!room?.localParticipant || publishedVideoTrack) {
          return publishedVideoTrack;
        }

        const canvas = await locateAvatarCanvas();
        if (!canvas || typeof canvas.captureStream !== 'function') {
          addMessage('system', 'Avatar video streaming is not supported in this browser.');
          return null;
        }

        try {
          attemptedAvatarStream = true;
          const fps = Number.parseInt(runtime.AVATAR_STREAM_FPS ?? '24', 10);
          const stream = canvas.captureStream(Number.isFinite(fps) && fps > 0 ? fps : 24);
          const [mediaTrack] = stream.getVideoTracks();
          if (!mediaTrack) {
            throw new Error('Ready Player Me canvas did not expose a video track');
          }

          mediaTrack.onended = () => {
            addMessage('system', 'Avatar capture stopped.');
            stopAvatarVideoTrack(room);
          };

          avatarStreamTrack = mediaTrack;
          const localTrack = LocalVideoTrack.createFromMediaStreamTrack(mediaTrack);
          const publication = await room.localParticipant.publishTrack(localTrack, {
            source: Track.Source.Camera,
          });

          avatarVideoPublication = publication;
          publishedVideoTrack = localTrack;
          addMessage('system', 'Avatar video streaming active.');
          return localTrack;
        } catch (error) {
          console.error('Avatar capture failed', error);
          addMessage('system', `Avatar video unavailable: ${error.message}`);
          stopAvatarVideoTrack(room);
          return null;
        }
      }

      function stopAvatarVideoTrack(room) {
        const participant = room?.localParticipant || activeRoom?.localParticipant;
        if (avatarVideoPublication && participant) {
          try {
            participant.unpublishTrack(avatarVideoPublication, true);
          } catch (error) {
            console.warn('Failed to unpublish avatar track', error);
          }
        }
        avatarVideoPublication = null;

        if (publishedVideoTrack) {
          try {
            publishedVideoTrack.stop();
          } catch (error) {
            console.warn('Failed to stop avatar video track', error);
          }
        }
        publishedVideoTrack = null;

        if (avatarStreamTrack) {
          avatarStreamTrack.stop();
        }
        avatarStreamTrack = null;
        attemptedAvatarStream = false;
      }

      const runtime = window.RUNTIME || {};
      const rpmSubdomain = (runtime.READY_PLAYER_ME_SUBDOMAIN || 'demo').trim();
      rpmFrame.src = `https://${rpmSubdomain}.readyplayer.me/avatar?frameApi`;

      let activeRoom = null;
      let publishedMicTrack = null;

      function setStatus(text, isError = false) {
        statusLine.textContent = text;
        const label = isError ? 'error' : activeRoom ? 'online' : 'offline';
        connectionTag.textContent = `Status: ${label}`;
        connectionTag.style.borderColor = isError ? 'rgba(255,107,138,0.6)' : 'rgba(99,245,255,0.5)';
        connectionTag.style.background = isError ? 'rgba(255,107,138,0.12)' : 'rgba(99,245,255,0.12)';
      }

      function addMessage(type, text) {
        const entry = document.createElement('div');
        entry.classList.add('chat-message', type);
        entry.textContent = text;
        chatLog.appendChild(entry);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      let currentAvatarUrl = null;
      let fallbackAvatarUrl = 'https://readyplayerme-avatars.s3.amazonaws.com/benchmark.glb?pose=standing';

      const READY_PLAYER_ME_PREFIXES = [
        'https://models.readyplayer.me/',
        'https://readyplayerme-avatars.s3.amazonaws.com/',
        'https://d1a370nemizbjq.cloudfront.net/',
        'https://cdn.readyplayer.me/',
        `https://${rpmSubdomain}.readyplayer.me/`,
      ];

      function beginAvatarLoad(url) {
        if (!url) {
          return;
        }
        resetAvatarReadyPromise();
        avatarStatus.textContent = `Loading avatar from ${url} ...`;
        viewer.removeAttribute('src');
      }

      function setAvatar(url) {
        if (!url) {
          viewer.removeAttribute('src');
          avatarStatus.textContent = 'Avatar URL: none';
          downloadAvatarLink.href = '#';
          currentAvatarUrl = null;
          return;
        }
        currentAvatarUrl = url;
        beginAvatarLoad(url);
        viewer.setAttribute('src', url);
        viewer.setAttribute('crossorigin', 'anonymous');
        avatarStatus.textContent = `Avatar URL: ${url}`;
        downloadAvatarLink.href = url;
      }

      function showCreator(show) {
        rpmFrame.hidden = !show;
        closeCreatorBtn.disabled = !show;
      }

      function isValidReadyPlayerMeUrl(url) {
        if (!url) return false;
        const normalized = url.trim();
        if (!normalized) return false;
        if (!normalized.includes('.glb')) return false;
        return READY_PLAYER_ME_PREFIXES.some((prefix) => normalized.startsWith(prefix));
      }

      viewer.addEventListener('load', () => {
        markAvatarReady();
        if (!currentAvatarUrl) {
          return;
        }
        avatarStatus.textContent = `Avatar loaded from ${currentAvatarUrl}`;
        fallbackAvatarUrl = currentAvatarUrl;
      });

      viewer.addEventListener('error', () => {
        markAvatarReady();
        if (!currentAvatarUrl) {
          return;
        }
        const failedUrl = currentAvatarUrl;
        const message = `Avatar failed to load from ${failedUrl}. Falling back to the last working model.`;
        avatarStatus.textContent = message;
        addMessage('system', message);
        if (fallbackAvatarUrl && fallbackAvatarUrl !== failedUrl) {
          setAvatar(fallbackAvatarUrl);
        }
      });

      loadPresetBtn.addEventListener('click', () => {
        const url = avatarPreset.value;
        if (!url) {
          alert('Select an avatar preset first.');
          return;
        }
        setAvatar(url);
      });

      loadFromUrlBtn.addEventListener('click', () => {
        const url = avatarUrlInput.value.trim();
        if (!isValidReadyPlayerMeUrl(url)) {
          alert('Please provide a valid Ready Player Me GLB URL.');
          return;
        }
        setAvatar(url);
      });

      openCreatorBtn.addEventListener('click', () => showCreator(true));
      closeCreatorBtn.addEventListener('click', () => showCreator(false));

      window.addEventListener('message', (event) => {
        if (typeof event.data !== 'string') return;
        try {
          const message = JSON.parse(event.data);
          if (message.source !== 'readyplayerme') return;
          if (message.eventName === 'v1.frame.ready') {
            rpmFrame.contentWindow?.postMessage(JSON.stringify({
              target: 'readyplayerme',
              type: 'subscribe',
              eventName: 'v1.**'
            }), '*');
          }
          if (message.eventName === 'v1.avatar.exported') {
            const url = message.data?.url;
            if (isValidReadyPlayerMeUrl(url)) {
              setAvatar(url);
              avatarUrlInput.value = url;
              showCreator(false);
              addMessage('system', 'Avatar updated from Creator.');
            } else {
              const warning = 'Creator returned an unsupported URL. Paste it manually if you trust the source.';
              avatarStatus.textContent = warning;
              addMessage('system', warning);
            }
          }
        } catch (error) {
          console.warn('Ready Player Me message error', error);
        }
      });

      async function connectToRoom() {
        if (activeRoom) return;
        setStatus('Connecting...');
        connectBtn.disabled = true;
        attemptedAvatarStream = false;
        stopAvatarVideoTrack();
        try {
          if (!runtime.LIVEKIT_URL) {
            throw new Error('LIVEKIT_URL is not configured on the server.');
          }
          const roomName = roomInput.value.trim() || 'avatar-room';
          const identity = identityInput.value.trim() || `user-${Date.now()}`;
          const response = await fetch(`/token?room=${encodeURIComponent(roomName)}&identity=${encodeURIComponent(identity)}`);
          const payload = await response.json().catch(() => null);
          if (!response.ok) {
            const message =
              (payload && typeof payload === 'object' && 'error' in payload && payload.error) ||
              (typeof payload === 'string' ? payload : response.statusText);
            throw new Error(message || 'Token request failed');
          }
          const token = payload?.token;
          const url = payload?.url;
          if (!token || !url) {
            throw new Error('Token endpoint did not return LiveKit credentials.');
          }

          const room = new Room({ adaptiveStream: true, dynacast: true, stopLocalTrackOnUnpublish: true });

          room.on(RoomEvent.TrackSubscribed, (track, publication, participant) => {
            if (track.kind === Track.Kind.Audio) {
              track.attach(remoteAudio);
              remoteAudio.hidden = false;
              remoteAudio.play().catch((err) => console.warn('Audio playback blocked', err));
              addMessage('system', `Audio active from ${participant.identity ?? 'agent'}.`);
            }
            if (track.kind === Track.Kind.Video) {
              track.attach(remoteVideo);
              remoteVideo.hidden = false;
            }
          });

          room.on(RoomEvent.TrackUnsubscribed, (track) => {
            track.detach();
            if (track.kind === Track.Kind.Audio) remoteAudio.hidden = true;
            if (track.kind === Track.Kind.Video) remoteVideo.hidden = true;
          });

          room.on(RoomEvent.DataReceived, (payload, participant) => {
            const text = textDecoder.decode(payload);
            const sender = participant?.identity && !participant.isLocal ? participant.identity : 'Agent';
            addMessage('agent', `${sender}: ${text}`);
          });

          room.on(RoomEvent.Disconnected, () => {
            addMessage('system', 'Room disconnected.');
            cleanupRoom();
          });

          await room.connect(url, token);

          const tracks = await createLocalTracks({ audio: true });
          const micTrack = tracks.find((t) => t.kind === Track.Kind.Audio);
          if (micTrack) {
            await room.localParticipant.publishTrack(micTrack, { source: Track.Source.Microphone });
            publishedMicTrack = micTrack;
          }

          await startAvatarVideoTrack(room);

          activeRoom = room;
          addMessage('system', `Connected as ${room.localParticipant.identity}.`);
          setStatus(`Connected to ${roomName}.`);
          messageInput.disabled = false;
          sendBtn.disabled = false;
          disconnectBtn.disabled = false;
        } catch (error) {
          console.error('Connection error', error);
          setStatus(`Error: ${error.message}`, true);
          addMessage('system', `Connection failed: ${error.message}`);
          connectBtn.disabled = false;
        }
      }

      function cleanupRoom() {
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        messageInput.disabled = true;
        sendBtn.disabled = true;
        remoteVideo.hidden = true;
        remoteAudio.hidden = true;
        publishedMicTrack?.stop();
        publishedMicTrack = null;
        stopAvatarVideoTrack(activeRoom);
        if (activeRoom) {
          activeRoom.disconnect();
          activeRoom = null;
        }
        setStatus('Ready to connect.');
      }

      function disconnectFromRoom() {
        if (!activeRoom) return;
        addMessage('system', 'Disconnected manually.');
        cleanupRoom();
      }

      async function sendChatMessage() {
        const text = messageInput.value.trim();
        if (!text || !activeRoom) return;
        addMessage('user', `You: ${text}`);
        messageInput.value = '';
        try {
          await activeRoom.localParticipant.publishData(textEncoder.encode(text), { reliable: true, topic: 'chat' });
        } catch (error) {
          console.error('Send failed', error);
          addMessage('system', `Send failed: ${error.message}`);
        }
      }

      connectBtn.addEventListener('click', connectToRoom);
      disconnectBtn.addEventListener('click', disconnectFromRoom);
      sendBtn.addEventListener('click', sendChatMessage);
      messageInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          sendChatMessage();
        }
      });

      window.addEventListener('beforeunload', () => {
        if (activeRoom) {
          stopAvatarVideoTrack(activeRoom);
          activeRoom.disconnect();
        }
      });

        addMessage('system', 'Welcome! Load your avatar and connect to the room.');
        setAvatar('https://readyplayerme-avatars.s3.amazonaws.com/benchmark.glb?pose=standing');
      })().catch((error) => {
        console.error('Failed to initialise LiveKit cockpit', error);
        const statusLine = document.getElementById('statusLine');
        if (statusLine) {
          statusLine.textContent = `LiveKit SDK failed to load: ${error.message}`;
        }
      });
    </script>
  </body>
</html>
